# Widgetbook with Riverpod

**Widgetbook** is a Flutter package that helps developers **visualise and test widgets** in different states. It can be integrated with Riverpod, a state management library for Flutter, to make it even more efficient.

To integrate Widgetbook with Riverpod in the Flutter application, this recipe uses the following steps:

1. **Adding required dependencies**
2. **Initialize Firebase**
3. **Set Up Riverpod Provider**
4. **Create UI**
5. **Configure Widgetbook**
6. **Generating the Widgetbook**
7. **Creating Components & Use-cases**
8. **Add Addons**
9. **Testing the widgets**
10. **Run Widgetbook**
11. **Conclusion**

# **1. Add Dependencies:**

Make sure you have the dependencies required in your **`pubspec.yaml`** file:

```yaml

dependencies:
  flutter:
    sdk: flutter
  cloud_firestore: ^4.4.5
  firebase_core:
  firebase_auth: ^4.4.2
  flutter_riverpod: ^2.4.4
  widgetbook_annotation: ^3.0.0
  widgetbook: ^3.3.0

```

Run **`flutter pub get`** in your terminal to fetch the new dependencies.

# **2. Initialise Firebase:**

```dart
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await Firebase.initializeApp();

  runApp(
    const ProviderScope(
      child: MyApp(),
    ),
  );
}
```

# 3**. Set Up Riverpod Provider:**

**Provider Setup:** 

Create providers for **`AuthProvider`**, **`FirebaseAuth`**, and an **`authStateProvider`**, which handles the authentication-related functionality with monitoring state changes.

```dart
final authProvider = Provider<AuthProvider>((ref) => AuthProvider());
final firebaseAuthProvider =
    Provider<FirebaseAuth>((ref) => FirebaseAuth.instance);
final authStateProvider =
    StreamProvider((ref) => ref.watch(firebaseAuthProvider).authStateChanges());
```

**User Login Method:**

Implement a method to log in a user using Firebase authentication.

```dart
Future<UserCredential?> loginUserWithFirebase(String email, String password) async {
  try {
    _authUserCredential = await authClass.loginUserWithFirebase(email, password);
    return _authUserCredential;
  } catch (e) {
    return Future.error(e);
  }
}
```

**User Signup Method:**

Implement a method for user signup, including adding user data to Firestore.

```dart
Future<UserCredential?> signUpUserWithFirebase(
    String email,
    String password,
    String name,
  ) async {
    var isSuccess = false;Future<UserCredential?> loginUserWithFirebase(
    String email,
    String password,
  ) async {
    try {
      _authUserCredential =
          await authClass.loginUserWithFirebase(email, password);

      return _authUserCredential;
    } catch (e) {
      return Future.error(e);
    }
  }

    _authUserCredential =
        await authClass.signUpUserWithFirebase(email, password, name);

    final DataModel dataModel = DataModel(
      name: name,
      email: email,
      uid: _authUserCredential!.user!.uid,
    );

    String userid = _authUserCredential!.user!.uid;
    isSuccess = await addUserToDatabase(dataModel, 'user', userid);
    if (isSuccess) {
      return _authUserCredential!;
    } else {
      throw Exception("error while signup the user");
    }
  }
```

**Add User to Firestore Method:**

Implement a method to add user data to Firestore.

```dart
Future<bool> addUserToDatabase(
    DataModel data,
    String collectionName,
    String docName,
  ) async {
    var value = false;

    try {
      await fstore.addDataToFirestore(data, collectionName, docName);
      value = true;
    } catch (e) {
      value = false;
    }
    return value;
  }
```

**Logout Method:**

Implement a method to log out the user.

```dart
void logoutUser() {
  authClass.signOut();
}
```

Complete code for `auth_riverpod.dart`ðŸ‘‡

```dart
import 'package:cookbook1/model/user_model.dart';
import 'package:cookbook1/services/abstract/firestore_service.dart';
import 'package:cookbook1/services/firebase_auth.dart';
import 'package:cookbook1/services/firestore_data_service.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final authProvider = Provider<AuthProvider>((ref) => AuthProvider());

final firebaseAuthProvider =
    Provider<FirebaseAuth>((ref) => FirebaseAuth.instance);
final authStateProvider =
    StreamProvider((ref) => ref.watch(firebaseAuthProvider).authStateChanges());

class AuthProvider {
  UserCredential? _authUserCredential;
  FirebaseAuthClass authClass = FirebaseAuthClass();
  BaseFirestoreService fstore = FirestoreService();
  UserCredential? get authUserCredential => _authUserCredential;

  Future<UserCredential?> loginUserWithFirebase(
    String email,
    String password,
  ) async {
    try {
      _authUserCredential =
          await authClass.loginUserWithFirebase(email, password);

      return _authUserCredential;
    } catch (e) {
      return Future.error(e);
    }
  }

  Future<UserCredential?> signUpUserWithFirebase(
    String email,
    String password,
    String name,
  ) async {
    var isSuccess = false;

    _authUserCredential =
        await authClass.signUpUserWithFirebase(email, password, name);

    final DataModel dataModel = DataModel(
      name: name,
      email: email,
      uid: _authUserCredential!.user!.uid,
    );

    String userid = _authUserCredential!.user!.uid;
    isSuccess = await addUserToDatabase(dataModel, 'user', userid);
    if (isSuccess) {
      return _authUserCredential!;
    } else {
      throw Exception("error while signup the user");
    }
  }

  Future<bool> addUserToDatabase(
    DataModel data,
    String collectionName,
    String docName,
  ) async {
    var value = false;

    try {
      await fstore.addDataToFirestore(data, collectionName, docName);
      value = true;
    } catch (e) {
      value = false;
    }
    return value;
  }

  void logoutUser() {
    authClass.signOut();
  }
}
```

# 4**. Create UI**

Build simple signup, login, and home screens using Firebase Auth & Riverpod.

[Screen Recording 2023-10-17 at 17.28.24.mov](Widgetbook%20with%20Riverpod%20ffe8ad8bf8db4a2db385ad3f4f22c670/Screen_Recording_2023-10-17_at_17.28.24.mov)

## SignUp page

**Create `SignUp` Widget:**

Define a stateful widget named **`SignUp`** extending **`ConsumerWidget`**.

```dart
class SignUp extends ConsumerWidget {
  SignUp({Key? key});
```

**Text Controllers:**

Create **`TextEditingController`** instances for email, password, and name.

```dart
final TextEditingController emailController = TextEditingController();
final TextEditingController passController = TextEditingController();
final TextEditingController nameController = TextEditingController();
```

**Sign-Up Button Action:**

Implement the sign-up button action using the **`authNotifier`**.

```dart
onPressed: () {
  authNotifier.signUpUserWithFirebase(
    emailController.text,
    passController.text,
    nameController.text,
  ).then((value) {
    if (value?.user != null) {
      Navigator.push(
        context,
        MaterialPageRoute(builder: (_) => const Home()),
      );
    }
  });
},
```

## Login page

**Create `LoginPage` Widget:**

Similar to Signup page define a stateful widget named **`LoginPage`** extending **`ConsumerWidget`**. and create **`TextEditingController`** instances for email and password.

**Build Method:**

Implement the **`build`** method to create the UI using Riverpod.

```dart
@override
Widget build(BuildContext context, WidgetRef ref) {
  final authNotifier = ref.read(authProvider);
  return Scaffold(
    // ... (see below)
  );
}
```

**Login Form:**

Utilize the custom **`CustomForm`** widget for the login form.

```dart
LoginForm(
  emailController: emailController,
  passController: passController,
  formAssetColor: AppColor.myWhite,
  onPressed: () {
    // ... (see below)
  },
  onTap: () {
    // Navigate to SignUp Page
    Navigator.push(
      context,
      MaterialPageRoute(builder: (_) => SignUp()),
    );
  },
),
```

**Login Button Action:**

Implement the login button action using the **`authNotifier`**.

```dart
onPressed: () {
  authNotifier.loginUserWithFirebase(
    emailController.text,
    passController.text,
  ).then((value) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (_) => const Home(),
      ),
    );
  });
},
```

## Home page

**Create `Home` Widget:**

**`Home`** is Stateless widget to make it more concise and focused on the logout functionality

**Add Logout Button with Riverpod Consumer:**

```dart
actions: [
  Consumer(
    builder: (context, ref, child) {
      final authNotifier = ref.watch(authProvider);
      return IconButton(
        onPressed: () {
          authNotifier.logoutUser();
          Navigator.push(
            context,
            MaterialPageRoute(builder: (_) => LoginPage()),
          );
        },
        icon: const Icon(
          Icons.logout,
          color: AppColor.myWhite,
        ),
      );
    },
  ),
],`home.dart`
```

# 5**. Configure Widgetbook:**

There are two approaches to configuring Widgetbook:
**Manual Approach**: This approach involves using theÂ **[widgetbook package](https://pub.dev/packages/widgetbook)**Â and manually maintaining and other is **Generator Approach** ensures harmony between your codebase and the Widgetbook's navigation panel structure to know more about widgetbook configure check **[here](https://docs.widgetbook.io/getting-started/setup)**

# 6**. Generating the widgetbook:**

This recipe uses Generator approach, which utilizes the **[build_runner](https://pub.dev/packages/build_runner)** package to generate the necessary code.

To execute the generator, run the following command:

```dart
flutter pub run build_runner build

```

1. The generator will create a `widgetbook.directories.g.dart` file in the same directory as the annotated file. This file will contain a variable named `directories`.

To set up your Widgetbook, follow the usual steps. For the `directories` property, use the generated `directories` variable from the `widgetbook.directories.g.dart` file.

file structure

The generator will create a **`widgetbook.directories.g.dart`** file in the same directory as the annotated file. This file will contain a variable named **`directories`**.

Organize your project structure as follows:

```dart

â”œâ”€ ios
â”œâ”€ lib
â”œ â”œâ”€ main.dart
â”œ â”œâ”€ widgetbook.dart
â”œ â”œâ”€ widgetbook.directories.g.dart
â”œâ”€ pubspec.yaml

```

Create a **`widgetbook.dart`** file to configure Widgetbook:

```dart
// widgetbook.dart

import 'package:cookbook1/widgetbook.directories.g.dart';
import 'package:flutter/material.dart';
import 'package:widgetbook/widgetbook.dart';
import 'package:widgetbook_annotation/widgetbook_annotation.dart' as widgetbook;

// Import the generated directories variable

void main() {
  runApp(const WidgetbookApp());
}

@widgetbook.App()
class WidgetbookApp extends StatelessWidget {
  const WidgetbookApp({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Widgetbook.material(
      // Use the generated directories variable
      directories: directories,
      addons: [
          ],
         
        ),
      ],
    );
  }
}
```

# 7**. Creating Components & Use-cases**

Widgetbook features aÂ ***component***Â andÂ ***use-case***Â approach in which a single component has one or multiple use-cases. For learn more about components & use-cases check [here](https://docs.widgetbook.io/getting-started/components)

  ***`CustomButton`** which is simple TextButton component.* 

```dart
import 'package:flutter/material.dart';
import 'package:widgetbook_annotation/widgetbook_annotation.dart' as widgetbook;

class CustomButton extends StatelessWidget {
  const CustomButton({
    required this.buttonTitle,
    required this.onPressed,
    required this.buttonbackColor,
    super.key,
  });
  final String buttonTitle;
  final VoidCallback onPressed;
  final Color buttonbackColor;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(10.0),
      child: Container(
          height: 60,
          width: 300,
          decoration: BoxDecoration(
              color: buttonbackColor,
              borderRadius: const BorderRadius.all(Radius.circular(10))),
          child: TextButton(
              onPressed: onPressed,
              child: Text(
                buttonTitle,
                style: const TextStyle(
                  color: Colors.redAccent,
                  fontSize: 20,
                ),
              ))),
    );
  }
}

```

adding use cases to ***`CustomButton`** component. use cases are the variation in same component just like below same component with different* `buttonTitle` and `buttonbackColor`

To create a use case, you need to use the `@usecase` annotation and specify the `name` and `type`. You can find a detailed explanation on how to create components and use cases [here](https://docs.widgetbook.io/getting-started/components).

`custom_button.dart`

```dart
@widgetbook.UseCase(
  name: 'default',
  type: CustomButton,
)
CustomButton blackColorButton(BuildContext context) {
  return CustomButton(
    buttonTitle: 'Login',
    onPressed: () {},
    buttonbackColor: const Color.fromARGB(255, 255, 255, 255),
  );
}

@widgetbook.UseCase(
  name: 'blue button',
  type: CustomButton,
)
CustomButton blueColorButton(BuildContext context) {
  return CustomButton(
    buttonTitle: 'Login',
    onPressed: () {},
    buttonbackColor: const Color.fromARGB(255, 22, 7, 233),
  );
}
```

Here is list for all component for this recipe

```dart

â”œâ”€ components
â”œ â”œâ”€ custom_button.dart
â”œ â”œâ”€ custom_form.dart
â”œ â”œâ”€ custom_image.dart
â”œ â”œâ”€ custom_textform_field.dart
â”œ â”œâ”€ custom_title_text.dart

```

`custom_form.dart`

We've incorporated two use cases in this component, each featuring distinct colors for the form elements.

![Untitled](Widgetbook%20with%20Riverpod%20ffe8ad8bf8db4a2db385ad3f4f22c670/Untitled.png)

```dart
import 'package:cookbook1/screens/components/custom_button.dart';
import 'package:cookbook1/screens/components/custom_textform_field.dart';
import 'package:cookbook1/screens/signup.dart';
import 'package:flutter/material.dart';
import 'package:widgetbook_annotation/widgetbook_annotation.dart' as widgetbook;

class LoginForm extends StatelessWidget {
  const LoginForm({
    super.key,
    required this.emailController,
    required this.passController,
    // required this.authNotifer,
    required this.onPressed,
    required this.formAssetColor,
  });

  final TextEditingController emailController;
  final TextEditingController passController;
  // AuthProvider authNotifer = AuthProvider();
  final Color formAssetColor;
  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: Container(
          color: const Color.fromARGB(255, 244, 87, 73),
          child: Padding(
            padding: const EdgeInsets.all(15.0),
            child: Column(
              children: [
                CustomTextFormField(
                  controller: emailController,
                  hintText: "Email",
                  textFieldColor: formAssetColor,
                  suffixIcon: Icons.email,
                  obscureText: false,
                ),
                CustomTextFormField(
                  controller: passController,
                  hintText: "Password",
                  textFieldColor: formAssetColor,
                  suffixIcon: Icons.lock,
                  obscureText: true,
                ),
                const SizedBox(
                  height: 20,
                ),
                CustomButton(
                  buttonTitle: "Login",
                  buttonbackColor: formAssetColor,
                  onPressed: onPressed,
                ),
                GestureDetector(
                    onTap: () {
                      Navigator.push(
                          context, MaterialPageRoute(builder: (_) => SignUp()));
                    },
                    child: Text(
                      "New user? Sign Up",
                      style: TextStyle(color: formAssetColor, fontSize: 15),
                    ))
              ],
            ),
          )),
    );
  }
}

@widgetbook.UseCase(
  name: 'Default',
  type: LoginForm,
)
LoginForm defaultColor(BuildContext context) {
  final TextEditingController emailController = TextEditingController();
  final TextEditingController passController = TextEditingController();

  return LoginForm(
      emailController: emailController,
      passController: passController,
      onPressed: () {},
      formAssetColor: Colors.white);
}

@widgetbook.UseCase(
  name: 'grey color',
  type: LoginForm,
)
LoginForm blackColor(BuildContext context) {
  final TextEditingController emailController = TextEditingController();
  final TextEditingController passController = TextEditingController();

  return LoginForm(
    emailController: emailController,
    passController: passController,
    onPressed: () {},
    formAssetColor: const Color.fromARGB(255, 72, 71, 71),
  );
}
```

`custom_image.dart`

In this component, we're examining two different sizes of images.

![Untitled](Widgetbook%20with%20Riverpod%20ffe8ad8bf8db4a2db385ad3f4f22c670/Untitled%201.png)

```dart
import 'package:flutter/material.dart';
import 'package:widgetbook_annotation/widgetbook_annotation.dart' as widgetbook;

class CustomImage extends StatelessWidget {
  const CustomImage({
    required this.height,
    required this.width,
    super.key,
  });
  final double height;
  final double width;

  @override
  Widget build(BuildContext context) {
    return Image.asset(
      "assets/images/cooking.jpg",
      height: height,
      width: width,
      fit: BoxFit.contain,
    );
  }
}
@widgetbook.UseCase(
  name: 'Default Style',
  type: CustomImage,
)
CustomImage defaultSize(BuildContext context) {
  return const CustomImage(
    height: 300,
    width: 300,
  );
}
@widgetbook.UseCase(
  name: 'small size',
  type: CustomImage,
)
CustomImage defaultSmallSize(BuildContext context) {
  return const CustomImage(
    height: 100,
    width: 100,
  );
}
```

`custom_textform_field.dart`

In this component, we've implemented a distinct color for the text field and a different icons.

```dart
import 'package:flutter/material.dart';
import 'package:widgetbook_annotation/widgetbook_annotation.dart' as widgetbook;

class CustomTextFormField extends StatelessWidget {
  const CustomTextFormField({
    required this.controller,
    required this.hintText,
    required this.textFieldColor,
    required this.suffixIcon,
    required this.obscureText,
    super.key,
  });
  final TextEditingController controller;
  final String hintText;
  final Color textFieldColor;
  final IconData suffixIcon;
  final bool obscureText;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(8.0),
      child: TextFormField(
        obscureText: obscureText,
        style: const TextStyle(color: Colors.white),
        textAlignVertical: TextAlignVertical.center,
        controller: controller,
        decoration: InputDecoration(
          fillColor: textFieldColor,
          hintText: hintText,
          suffixIcon: Icon(
            suffixIcon,
            color: textFieldColor,
          ),
          hintStyle: TextStyle(color: textFieldColor),
          hoverColor: textFieldColor,
          border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(10),
              borderSide: BorderSide(color: textFieldColor, width: 3)),
          enabled: true,
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: BorderSide(color: textFieldColor, width: 2),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: BorderSide(color: textFieldColor),
          ),
        ),
      ),
    );
  }
}

@widgetbook.UseCase(
  name: 'yellow field color',
  type: CustomTextFormField,
)
CustomTextFormField defaultCustomTitle(BuildContext context) {
  TextEditingController testController = TextEditingController();
  return CustomTextFormField(
    controller: testController,
    hintText: 'hello',
    textFieldColor: Colors.yellow,
    suffixIcon: Icons.headphones,Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  await Firebase.initializeApp();

  runApp(const ProviderScope(child: MyApp()));
}
    obscureText: true,
  );
}
@widgetbook.UseCase(
  name: 'blue field color',
  type: CustomTextFormField,
)
CustomTextFormField defaultCustomTitle1(BuildContext context) {
  TextEditingController testController = TextEditingController();
  return CustomTextFormField(
    controller: testController,
    hintText: 'hello',
    textFieldColor: Colors.blue,
    suffixIcon: Icons.headphones,
    obscureText: true,
  );
}
```

`custom_title_text.dart`

Similarly, in this component, we have two different color variations.

```dart
import 'package:flutter/material.dart';

import 'package:widgetbook_annotation/widgetbook_annotation.dart' as widgetbook;

class CustomTitleText extends StatelessWidget {
  const CustomTitleText({
    required this.titleText,
    required this.titleTextColor,
    super.key,
  });
  final String titleText;
  final Color titleTextColor;

  @override
  Widget build(BuildContext context) {
    return Text(
      titleText,
      style: TextStyle(color: titleTextColor),
    );
  }
}

@widgetbook.UseCase(
  name: 'Default Style',
  type: CustomTitleText,
)
CustomTitleText defaultCustomTitle(BuildContext context) {
  return const CustomTitleText(
    titleText: 'login page',
    titleTextColor: Color.fromARGB(255, 255, 255, 255),
  );
}

@widgetbook.UseCase(
  name: 'blue color',
  type: CustomTitleText,
)
CustomTitleText blueColor(BuildContext context) {
  return const CustomTitleText(
    titleText: 'login page',
    titleTextColor: Colors.blue,
  );
}
```

# 9****. Add  Addons****

Addons in Widgetbook present a versatile and customizable approach to elevate your development environment. You have the choice to utilize pre-existing Addons or craft your own to suit your unique requirements. Refer to the documentation [here](https://docs.widgetbook.io/getting-started/knobs) for comprehensive details on adding Addons and exploring all the available features.

In this recipe we have used predefine `MaterialThemeAddon`,`TextScaleAddon`,`DeviceFrameAddon`Addons.

![Untitled](Widgetbook%20with%20Riverpod%20ffe8ad8bf8db4a2db385ad3f4f22c670/Untitled%202.png)

```dart
Widget build(BuildContext context) {
    return Widgetbook.material(
      // Use the generated directories variable
      directories: directories,
      addons: [
        MaterialThemeAddon(
          themes: [
            WidgetbookTheme(
              name: 'Light',
              data: ThemeData.light()
            ),
            WidgetbookTheme(
              name: 'Dark',
              data: ThemeData.dark()
            ),
          ],
        ),
        TextScaleAddon(
          scales: [1.0, 2.0, 3.0],
          initialScale: 1,
        ),
        DeviceFrameAddon(
          devices: [
            Devices.ios.iPhoneSE,
            Devices.ios.iPhone13,
          ],
          initialDevice: Devices.ios.iPhone13,
        ),
      ],
    );
  }
```

# 9**. Run Widgetbook:**

Before running Widgetbook, ensure that you've made any necessary changes to components or added new use cases. If modifications have been made, run the following command to ensure the code is up to date:

```dart

flutter pub run build_runner build

```

Now, you can run Widgetbook to check if everything works. Execute the following command to run Widgetbook on the web:

For information on running Widgetbook on different platforms, refer to the documentation [here](https://docs.widgetbook.io/getting-started/run). This step ensures that your Widgetbook environment is set up correctly and reflects any recent changes made to your Flutter widgets.

```dart
flutter run -d chrome -t lib/widgetbook.dart
```

![Untitled](Widgetbook%20with%20Riverpod%20ffe8ad8bf8db4a2db385ad3f4f22c670/Untitled%203.png)

Certainly, it appears that you have set up Widgetbook and run it successfully. Now, you can explore and test your components with their respective use cases in Widgetbook.

Let's create a few scenarios for testing different components:

1. **CustomButton:**
    - Use the "default" use case and ensure the button is displayed correctly.
    - Use the "blue button" use case and verify the appearance.
2. **LoginForm:**
    - Use the "Default" use case and make sure the form is displayed properly.
    - Use the "grey color" use case and check if the form color is applied correctly.
3. **CustomImage:**
    - Use the "Default Style" use case and observe the image with default dimensions.
    - Use the "small size" use case and confirm that the image size is adjusted accordingly.
4. **CustomTextFormField:**
    - Use the "yellow field color" use case and see if the text field has the correct color.
    - Use the "blue field color" use case and check if the text field color is updated.
5. **CustomTitleText:**
    - Use the "Default Style" use case and verify the appearance of the title text.
    - Use the "blue color" use case and ensure that the title text color is set correctly.

After setting up these scenarios, you can observe the components and use cases in Widgetbook, allowing you to visually inspect their appearance and behavior. This helps in quickly iterating and testing various configurations without having to run the entire application.

# 10****. Testing****

Writing widget tests is an essential part of the Flutter development process. By testing individual widgets, you can catch issues early in the development cycle and ensure that your UI components function as expected. The integration of Widgetbook and Riverpod further enhances the testing and visualization capabilities of your widgets, providing a comprehensive approach to Flutter development.

# 11****. Conclusion****

In this recipe, we've successfully integrated Widgetbook with Riverpod to visualize and test Flutter widgets in different states. This combination offers a powerful environment for developing and testing UI components.

[Screen Recording 2023-10-23 at 11.08.50.mov](Widgetbook%20with%20Riverpod%20ffe8ad8bf8db4a2db385ad3f4f22c670/Screen_Recording_2023-10-23_at_11.08.50.mov)

[Screen Recording 2023-10-17 at 17.28.24.mov](Widgetbook%20with%20Riverpod%20ffe8ad8bf8db4a2db385ad3f4f22c670/Screen_Recording_2023-10-17_at_17.28.24%201.mov)

Key takeaways:

- Widgetbook allows for easy visualization of widgets and their use cases.
- Riverpod facilitates effective state management in Flutter applications.
- Testing components and use cases within Widgetbook streamlines the development process.

This recipe serves as a foundation for creating robust and visually appealing Flutter applications. Feel free to explore additional features and customizations offered by Widgetbook to further enhance your development workflow. Happy coding!
